<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>knncolle_hnsw: knncolle_hnsw Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">knncolle_hnsw
   </div>
   <div id="projectbrief">knncolle bindings for HNSW</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">knncolle_hnsw Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>knncolle bindings for HNSW search.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html">DistanceConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance configuration for the HNSW index.  <a href="structknncolle__hnsw_1_1DistanceConfig.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle__hnsw_1_1HnswBuilder.html">HnswBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an approximate nearest neighbor search with HNSW.  <a href="classknncolle__hnsw_1_1HnswBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structknncolle__hnsw_1_1HnswOptions.html">HnswOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="classknncolle__hnsw_1_1HnswBuilder.html" title="Perform an approximate nearest neighbor search with HNSW.">HnswBuilder</a></code> and <code>HnswPrebuilt</code>.  <a href="structknncolle__hnsw_1_1HnswOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structknncolle__hnsw_1_1HnswPrebuiltTypes.html">HnswPrebuiltTypes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template types of a saved HNSW index.  <a href="structknncolle__hnsw_1_1HnswPrebuiltTypes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle__hnsw_1_1ManhattanDistance.html">ManhattanDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manhattan distance.  <a href="classknncolle__hnsw_1_1ManhattanDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classknncolle__hnsw_1_1SquaredEuclideanDistance.html">SquaredEuclideanDistance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared Euclidean distance.  <a href="classknncolle__hnsw_1_1SquaredEuclideanDistance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8040b86dbf364125600c3ffa0b17957d" id="r_a8040b86dbf364125600c3ffa0b17957d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8040b86dbf364125600c3ffa0b17957d">DistanceNormalizeMethod</a> : char { <b>SQRT</b>
, <b>CUSTOM</b>
, <b>NONE</b>
 }</td></tr>
<tr class="separator:a8040b86dbf364125600c3ffa0b17957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a939b7a0484ad0abb8ad2771e22b2f763" id="r_a939b7a0484ad0abb8ad2771e22b2f763"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ , typename HnswData_ &gt; </td></tr>
<tr class="memitem:a939b7a0484ad0abb8ad2771e22b2f763"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html">DistanceConfig</a>&lt; Distance_, HnswData_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a939b7a0484ad0abb8ad2771e22b2f763">configure_euclidean_distance</a> ()</td></tr>
<tr class="separator:a939b7a0484ad0abb8ad2771e22b2f763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac959f593dc491c48398c92d0aa56e579" id="r_ac959f593dc491c48398c92d0aa56e579"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ , typename HnswData_ &gt; </td></tr>
<tr class="memitem:ac959f593dc491c48398c92d0aa56e579"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html">DistanceConfig</a>&lt; Distance_, HnswData_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac959f593dc491c48398c92d0aa56e579">configure_manhattan_distance</a> ()</td></tr>
<tr class="separator:ac959f593dc491c48398c92d0aa56e579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9ea4c3758a81f63581b0880ae0434c" id="r_aaa9ea4c3758a81f63581b0880ae0434c"><td class="memTemplParams" colspan="2">template&lt;typename HnswData_ &gt; </td></tr>
<tr class="memitem:aaa9ea4c3758a81f63581b0880ae0434c"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name</a> (const hnswlib::SpaceInterface&lt; HnswData_ &gt; *distance)</td></tr>
<tr class="separator:aaa9ea4c3758a81f63581b0880ae0434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dba32a21f28000a286bf843dd06e37" id="r_ac7dba32a21f28000a286bf843dd06e37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structknncolle__hnsw_1_1HnswPrebuiltTypes.html">HnswPrebuiltTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7dba32a21f28000a286bf843dd06e37">load_hnsw_prebuilt_types</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:ac7dba32a21f28000a286bf843dd06e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346a21cc3b5f9146d23e5c9a060f3f4e" id="r_a346a21cc3b5f9146d23e5c9a060f3f4e"><td class="memTemplParams" colspan="2">template&lt;typename Index_ , typename Data_ , typename Distance_ , typename HnswData_  = float&gt; </td></tr>
<tr class="memitem:a346a21cc3b5f9146d23e5c9a060f3f4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a346a21cc3b5f9146d23e5c9a060f3f4e">load_hnsw_prebuilt</a> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a346a21cc3b5f9146d23e5c9a060f3f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c83b8e2126d6adac034de999fe3a5" id="r_ad52c83b8e2126d6adac034de999fe3a5"><td class="memTemplParams" colspan="2">template&lt;class HnswData_ &gt; </td></tr>
<tr class="memitem:ad52c83b8e2126d6adac034de999fe3a5"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const std::string &amp;)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad52c83b8e2126d6adac034de999fe3a5">custom_save_for_hnsw_data</a> ()</td></tr>
<tr class="separator:ad52c83b8e2126d6adac034de999fe3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7174a48a7415da18109520f5739da471" id="r_a7174a48a7415da18109520f5739da471"><td class="memTemplParams" colspan="2">template&lt;typename HnswData_ &gt; </td></tr>
<tr class="memitem:a7174a48a7415da18109520f5739da471"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const std::string &amp;, const hnswlib::SpaceInterface&lt; HnswData_ &gt; *)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7174a48a7415da18109520f5739da471">custom_save_for_hnsw_distance</a> ()</td></tr>
<tr class="separator:a7174a48a7415da18109520f5739da471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9593664dfabcb51e7d8aa8b4eb73728" id="r_af9593664dfabcb51e7d8aa8b4eb73728"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ &gt; </td></tr>
<tr class="memitem:af9593664dfabcb51e7d8aa8b4eb73728"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const std::string &amp;, const std::function&lt; Distance_(Distance_)&gt; &amp;)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af9593664dfabcb51e7d8aa8b4eb73728">custom_save_for_hnsw_normalize</a> ()</td></tr>
<tr class="separator:af9593664dfabcb51e7d8aa8b4eb73728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f743bb7f2ce610e32706f7500e5e27c" id="r_a1f743bb7f2ce610e32706f7500e5e27c"><td class="memTemplParams" colspan="2">template&lt;typename HnswData_ &gt; </td></tr>
<tr class="memitem:a1f743bb7f2ce610e32706f7500e5e27c"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; hnswlib::SpaceInterface&lt; HnswData_ &gt; *(const std::string &amp;, std::size_t)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f743bb7f2ce610e32706f7500e5e27c">custom_load_for_hnsw_distance</a> ()</td></tr>
<tr class="separator:a1f743bb7f2ce610e32706f7500e5e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cce88a44f275e0c8d06d6b893dee2d" id="r_a70cce88a44f275e0c8d06d6b893dee2d"><td class="memTemplParams" colspan="2">template&lt;typename Distance_ &gt; </td></tr>
<tr class="memitem:a70cce88a44f275e0c8d06d6b893dee2d"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; std::function&lt; Distance_(Distance_)&gt;(const std::string &amp;)&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70cce88a44f275e0c8d06d6b893dee2d">custom_load_for_hnsw_normalize</a> ()</td></tr>
<tr class="separator:a70cce88a44f275e0c8d06d6b893dee2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>knncolle bindings for HNSW search. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8040b86dbf364125600c3ffa0b17957d" name="a8040b86dbf364125600c3ffa0b17957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8040b86dbf364125600c3ffa0b17957d">&#9670;&#160;</a></span>DistanceNormalizeMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8040b86dbf364125600c3ffa0b17957d">knncolle_hnsw::DistanceNormalizeMethod</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Methods for distance normalization.</p>
<ul>
<li><code>SQRT</code> applies a square root, typically in conjunction with <code>hnswlib::L2Space</code> or <code><a class="el" href="classknncolle__hnsw_1_1SquaredEuclideanDistance.html" title="Squared Euclidean distance.">SquaredEuclideanDistance</a></code> to obtain the Euclidean distance.</li>
<li><code>CUSTOM</code> applies a custom normalization function in <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a8304619fe87fcb3fdaa0d6e109ec1a97">DistanceConfig::custom_normalize</a></code>.</li>
<li><code>NONE</code> does not apply any normalization of the distances. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a939b7a0484ad0abb8ad2771e22b2f763" name="a939b7a0484ad0abb8ad2771e22b2f763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939b7a0484ad0abb8ad2771e22b2f763">&#9670;&#160;</a></span>configure_euclidean_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ , typename HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html">DistanceConfig</a>&lt; Distance_, HnswData_ &gt; knncolle_hnsw::configure_euclidean_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configuration for using Euclidean distances in the HNSW index. <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a631f9820cbc2e7fbbeab10a78019d483">DistanceConfig::create</a></code> is set to <code>hnswlib::L2Space</code> if <code>HnswData_ = float</code>, otherwise it is set to <code><a class="el" href="classknncolle__hnsw_1_1SquaredEuclideanDistance.html" title="Squared Euclidean distance.">SquaredEuclideanDistance</a></code>. </dd></dl>

</div>
</div>
<a id="ac959f593dc491c48398c92d0aa56e579" name="ac959f593dc491c48398c92d0aa56e579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac959f593dc491c48398c92d0aa56e579">&#9670;&#160;</a></span>configure_manhattan_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ , typename HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html">DistanceConfig</a>&lt; Distance_, HnswData_ &gt; knncolle_hnsw::configure_manhattan_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configuration for using Manhattan distances in the HNSW index. </dd></dl>

</div>
</div>
<a id="a1f743bb7f2ce610e32706f7500e5e27c" name="a1f743bb7f2ce610e32706f7500e5e27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f743bb7f2ce610e32706f7500e5e27c">&#9670;&#160;</a></span>custom_load_for_hnsw_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; hnswlib::SpaceInterface&lt; HnswData_ &gt; *(const std::string &amp;, std::size_t)&gt; &amp; knncolle_hnsw::custom_load_for_hnsw_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to create a distance metric that is not known to <code><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name()</a></code> when loading a HNSW index from disk. Users are expected to provide their own function to regenerate any distance metric that was saved by <code><a class="el" href="#a7174a48a7415da18109520f5739da471">custom_save_for_hnsw_distance()</a></code>. Any modifications to this function are not thread-safe and should be done in a serial section.</p>
<p>The first argument to the global function is a file path <code>prefix</code>, same as that used in <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. The second argument should be the number of dimensions in the dataset. The global function should return a pointer to a <code>hnswlib::SpaceInterface</code> instance, similar to the behavior of <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a631f9820cbc2e7fbbeab10a78019d483">DistanceConfig::create()</a></code>.</p>
<p>The global function will only be called if the distance metric saved to <code>prefix</code> is unknown to <code><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name()</a></code>, otherwise it will ignored. An error is raised if no global function is set when attempting to load an index where <code><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name()</a></code> returns <code>"unknown"</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for creating a custom distance metric. By default, no function is provided. If set, the function will be called by the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method for the HNSW <code>Prebuilt</code> subclass. </dd></dl>

</div>
</div>
<a id="a70cce88a44f275e0c8d06d6b893dee2d" name="a70cce88a44f275e0c8d06d6b893dee2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cce88a44f275e0c8d06d6b893dee2d">&#9670;&#160;</a></span>custom_load_for_hnsw_normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; std::function&lt; Distance_(Distance_)&gt;(const std::string &amp;)&gt; &amp; knncolle_hnsw::custom_load_for_hnsw_normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to create a custom distance normalization function when loading a H NSW index from disk. Users are expected to provide their own function to regenerate any normalization function that was saved by <code><a class="el" href="#af9593664dfabcb51e7d8aa8b4eb73728">custom_save_for_hnsw_normalize()</a></code>. Any modifications to this function are not thread-safe and should be done in a serial section.</p>
<p>The sole argument to the global function is a file path <code>prefix</code>, same as that used in <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. The global function should return a normalization function equivalent to the <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a8304619fe87fcb3fdaa0d6e109ec1a97">DistanceConfig::custom_normalize()</a></code>.</p>
<p>The global function is only used when the <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a4aaf38f2e2c2dbe37c237456fa958280">DistanceConfig::normalize_method</a></code> saved to <code>prefix</code> is equal to <code>DistanceNormalizeMethod::CUSTOM</code>. otherwise it is ignored. An error is raised if no global function is set when attempting to load an index where <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a4aaf38f2e2c2dbe37c237456fa958280">DistanceConfig::normalize_method</a> == DistanceNormalizeMethod::CUSTOM</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Distance_</td><td>Floating point type for the distances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for creating a custom distance metric. By default, no function is provided. If set, the function will be called by the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method for the HNSW <code>Prebuilt</code> subclass. </dd></dl>

</div>
</div>
<a id="ad52c83b8e2126d6adac034de999fe3a5" name="ad52c83b8e2126d6adac034de999fe3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52c83b8e2126d6adac034de999fe3a5">&#9670;&#160;</a></span>custom_save_for_hnsw_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(const std::string &amp;)&gt; &amp; knncolle_hnsw::custom_save_for_hnsw_data </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to preserve <code>HnswData_</code> type information when saving a prebuilt Hnsw index in <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. Users should define their own function here to handle an <code>HnswData_</code> type that is unknown to <code><a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a84e640363d9246c58008c93166021f26">knncolle::get_numeric_type()</a></code>. The action of setting/unsetting the global function is not thread-safe and should be done in a serial section.</p>
<p>The sole argument of the global function is the same <code>prefix</code> provided to <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. The global function is generally expected to write to files at paths starting with <code>prefix</code>. It is recommended that an additional <code>_</code>, <code>-</code> or <code>.</code> is added to <code>prefix</code> to avoid conflicts with other files generated by <code>save()</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for saving information about <code>HnswData_</code>. By default, no global function is defined. If set, the global function will be called by the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method for the HNSW <code>Prebuilt</code> subclass. </dd></dl>

</div>
</div>
<a id="a7174a48a7415da18109520f5739da471" name="a7174a48a7415da18109520f5739da471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7174a48a7415da18109520f5739da471">&#9670;&#160;</a></span>custom_save_for_hnsw_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(const std::string &amp;, const hnswlib::SpaceInterface&lt; HnswData_ &gt; *)&gt; &amp; knncolle_hnsw::custom_save_for_hnsw_distance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to save extra information about a distance metric of a prebuilt HNSW index in <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. Users should define their own function here to handle a subclass of <code>hnswlib::SpaceInterface</code> that are unknown to <code><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name()</a></code>. The action of setting/unsetting the global function is not thread-safe and should be done in a serial section.</p>
<p>The first argument of the global function is the same <code>prefix</code> provided to <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. The second argument of the global function is a pointer to the distance metric used by the HNSW index. The global function is generally expected to write to files at paths starting with <code>prefix</code>. It is recommended that an additional <code>_</code>, <code>-</code> or <code>.</code> is added to <code>prefix</code> to avoid conflicts with other files generated by <code>save()</code>.</p>
<p>The global function is only used when the index to be saved uses an unknown distance metric, otherwise it is ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for saving information about the distance metric. By default, no global function is defined. If set, the global function will be called by the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method for the HNSW <code>Prebuilt</code> subclass. </dd></dl>

</div>
</div>
<a id="af9593664dfabcb51e7d8aa8b4eb73728" name="af9593664dfabcb51e7d8aa8b4eb73728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9593664dfabcb51e7d8aa8b4eb73728">&#9670;&#160;</a></span>custom_save_for_hnsw_normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Distance_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; void(const std::string &amp;, const std::function&lt; Distance_(Distance_)&gt; &amp;)&gt; &amp; knncolle_hnsw::custom_save_for_hnsw_normalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a global function to save a custom distance normalization method for a prebuilt HNSW index. <br  />
 Users should define their own function here to handle a <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a8304619fe87fcb3fdaa0d6e109ec1a97">DistanceConfig::custom_normalize</a></code> function. The action of setting/unsetting the global function is not thread-safe and should be done in a serial section.</p>
<p>The first argument of the global function is the same <code>prefix</code> provided to <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code>. The second argument of the global function is the <code><a class="el" href="structknncolle__hnsw_1_1DistanceConfig.html#a8304619fe87fcb3fdaa0d6e109ec1a97">DistanceConfig::custom_normalize</a></code> method used to construct the HNSW index. The global function is generally expected to write to files at paths starting with <code>prefix</code>. It is recommended that an additional <code>_</code>, <code>-</code> or <code>.</code> is added to <code>prefix</code> to avoid conflicts with other files generated by <code>save()</code>.</p>
<p>The global function is only used when the index to be saved uses a custom distance normalization method, otherwise it is ignored.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to a global function for saving information about the distance metric. By default, no global function is defined. If set, the global function will be called by the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method for the HNSW <code>Prebuilt</code> subclass. </dd></dl>

</div>
</div>
<a id="aaa9ea4c3758a81f63581b0880ae0434c" name="aaa9ea4c3758a81f63581b0880ae0434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9ea4c3758a81f63581b0880ae0434c">&#9670;&#160;</a></span>get_distance_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename HnswData_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const char * knncolle_hnsw::get_distance_name </td>
          <td>(</td>
          <td class="paramtype">const hnswlib::SpaceInterface&lt; HnswData_ &gt; *</td>          <td class="paramname"><span class="paramname"><em>distance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">HnswData_</td><td>Type of data in the HNSW index, usually floating-point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>Pointer to a distance metric. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String containing a name for each known metric, e.g., <code>"squared_euclidean"</code> for <code><a class="el" href="classknncolle__hnsw_1_1SquaredEuclideanDistance.html" title="Squared Euclidean distance.">SquaredEuclideanDistance</a></code>. </dd></dl>

</div>
</div>
<a id="a346a21cc3b5f9146d23e5c9a060f3f4e" name="a346a21cc3b5f9146d23e5c9a060f3f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346a21cc3b5f9146d23e5c9a060f3f4e">&#9670;&#160;</a></span>load_hnsw_prebuilt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index_ , typename Data_ , typename Distance_ , typename HnswData_  = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto knncolle_hnsw::load_hnsw_prebuilt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to define a <code><a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#af5bf682899b815f8e1d4a4c6ef80408a">knncolle::LoadPrebuiltFunction</a></code> for HNSW in <code>knncolle::load_prebuilt()</code>.</p>
<p>In an HNSW-specific <code><a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#af5bf682899b815f8e1d4a4c6ef80408a">knncolle::LoadPrebuiltFunction</a></code>, users should first call <code>scan_prebuilt_save_config()</code> to figure out the saved index's <code>HNSWData_</code>. Then, they can call <code><a class="el" href="#a346a21cc3b5f9146d23e5c9a060f3f4e">load_hnsw_prebuilt()</a></code> with the specified types to return a pointer to a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a></code> object. This can be registered in <code>load_prebuilt_registry()</code> with the key in <code>knncolle_hnsw::save_name</code>.</p>
<p>We do not define a default function for loading HNSW indices as there are too many possible combinations of types. Instead, the user is responsible for deciding which combinations of types should be handled. This avoids binary bloat from repeated instantiations of the HNSW template classes, if an application only deals with a certain subset of combinations. For types or distances that are unknown to <code><a class="elRef" href="https://knncolle.github.io/knncolle/namespaceknncolle.html#a84e640363d9246c58008c93166021f26">knncolle::get_numeric_type()</a></code> or <code><a class="el" href="#aaa9ea4c3758a81f63581b0880ae0434c">get_distance_name()</a></code>, respectively, users can store additional information on disk via <code>customize_save_for_hnsw_types()</code> for use in loading.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index_</td><td>Integer type for the observation indices. </td></tr>
    <tr><td class="paramname">Data_</td><td>Numeric type for the input and query data. </td></tr>
    <tr><td class="paramname">Distance_</td><td>Floating-point type for the distances. </td></tr>
    <tr><td class="paramname">HnswData_</td><td>Floating-point type for data in the HNSW index. This should be the same as the type reported by <code><a class="el" href="structknncolle__hnsw_1_1HnswPrebuiltTypes.html#a2e774092081ba86c4a178c49db3cf1ad">HnswPrebuiltTypes::data</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix of the file paths in which a prebuilt HNSW index was saved. An HNSW index is typically saved by calling the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method of the HNSW subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a></code> HNSW index. </dd></dl>

</div>
</div>
<a id="ac7dba32a21f28000a286bf843dd06e37" name="ac7dba32a21f28000a286bf843dd06e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dba32a21f28000a286bf843dd06e37">&#9670;&#160;</a></span>load_hnsw_prebuilt_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structknncolle__hnsw_1_1HnswPrebuiltTypes.html">HnswPrebuiltTypes</a> knncolle_hnsw::load_hnsw_prebuilt_types </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Prefix of the file paths in which a prebuilt HNSW index was saved. An HNSW index is typically saved by calling the <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html#a87930f878bf3a22297b851173caaf893">knncolle::Prebuilt::save()</a></code> method of the HNSW subclass instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Template types of the saved instance of a <code><a class="elRef" href="https://knncolle.github.io/knncolle/classknncolle_1_1Prebuilt.html">knncolle::Prebuilt</a></code> HNSW subclass. This is typically used to choose template parameters for <code><a class="el" href="#a346a21cc3b5f9146d23e5c9a060f3f4e">load_hnsw_prebuilt()</a></code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
